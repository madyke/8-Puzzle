#|
 |                  ***** SEARCH.LSP *****
 |
 | General-purpose exhaustive search routine includes both breadth-first
 | search and depth-first search. Uses graph search with OPEN and CLOSED
 | lists rather than tree search, to avoid cycles. Does not use heuristics
 | to limit or guide search.
 |
 | To solve a specific problem, the functions "generateSuccessors" and
 | "goalState?" must be defined. "generateSuccessors" takes a state as its
 | argument and returns a list of child states. "goalState?" returns T if
 | its argument is a goal state, NIL otherwise.
 |
 | In order to retrace a solution path, nodes are stored as (state parent)
 | pairs, where "state" is the current state and "parent" is the parent
 | state. Given a goal node, a solution path is generated by simply tracing
 | backwards through the parent states.
 |
 | Author: John M. Weiss, Ph.D.
 | Written Spring 2016 for CSC447/547 AI class.
 |
 | Modifications:
 |   3/20/2016 - Added statistics to track number of generated, distinct, and
 |                 expanded nodes.
 |   3/20/2016 - Altered node structure and DFS search to implement DFID.
 |   3/29/2016 - Adjusted DFID to also check closed list for depth bound.
 |
 |#

;--------------------------------------------------------------------------

; Node structure: stores state, parent, and depth.
(defstruct node state parent depth hValue (fValue 100))

; Test if two nodes have the same state.
(defun equal-states (n1 n2) (equal (node-state n1) (node-state n2)))

;--------------------------------------------------------------------------

; Breadth-first-search implements the OPEN list as a QUEUE of (state parent) nodes.
(defun BFS (start) (search_bfs_dfs ( copy-list start ) 'bfs))

; Depth-first-search implements the OPEN list as a STACK of (state parent) nodes.
(defun DFID (start)
    ;Perform DFID
    ( do
        ;Local vars
        ( 
            ( i 1 ( 1+ i ) )            ;DFID depth counter
            ( solutionFound? NIL )      ;Flag for solution found
        )        
        
        ;Termination condition - bounded DFS returns solution
        ( solutionFound? ( return solutionFound? ) )
        
        ;Loop body
        ;( format t "~%~%DFID SEARCH: ~d~%" i )
        ;( format t "~d nodes generated (~d distinct nodes), ~d nodes expanded~%~%"
        ;    *NUM_GEN*
        ;    *NUM_DIST*
        ;    *NUM_EXP*
        ;)
        
        ( setf solutionFound? ( search_bfs_dfs ( copy-list start ) 'dfid i ) )
    )
)

; Given a start state and a search type (BFS or DFID), return a path from the start to the goal.
(defun search_bfs_dfs (start type &optional bound)
    (do*                                                             ; note use of sequential DO*
        (                                                            ; initialize local loop vars
            (curNode (make-node :state start :parent nil :depth 0 :hValue 0 :fValue 0))  ; current node: (start nil 0)
            (OPEN (list curNode))                                    ; OPEN list:    ((start nil 0))
            (CLOSED nil)                                             ; CLOSED list:  ( )
        )

        ; termination condition - return solution path when goal is found
        ((goalState? (node-state curNode)) (build-solution curNode CLOSED))

        ; loop body
        (when (null OPEN) (return nil))             ; no solution
        ;( format t "~%OPEN LIST~%~s~%CLOSED LIST~%~s~%" OPEN CLOSED )
        
        ; get current node from OPEN, update OPEN and CLOSED
        (setf curNode (car OPEN))
        (setf OPEN (cdr OPEN))
        (setf CLOSED (cons curNode CLOSED))
        
        ; increment count of nodes expanded
        ( setf *NUM_EXP* ( 1+ *NUM_EXP* ) )

        ; add successors of current node to OPEN
        (dolist (child (generateSuccessors (node-state curNode)))

            ; for each child node
            (setf child (make-node  :state child
                                    :parent (node-state curNode)
                                    :depth (1+ (node-depth curNode))
									:hValue 0
									:fValue 0))
            ;( format t "CHILD: ~s~%" child )
            
            ; increment number of generated nodes
            ( setf *NUM_GEN* ( 1+ *NUM_GEN* ) )

            ; if the node is not on OPEN
            (when (not (member child OPEN   :test #'equal-states))
                ( let 
                    ;Local vars
                    (
                        ( temp ( car ( member child CLOSED :test #'equal-states ) ) )
                    )
                    
                    ; If node is not on CLOSED, or has larget depth bound
                    ( when  ( or    ( null temp )
                                    ( > (node-depth temp) (node-depth child) )
                            )
                        
                    
                        ; increment number of distinct nodes
                        ( setf *NUM_DIST* ( 1+ *NUM_DIST* ) )

                        ; add it to the OPEN list
                        (cond

                            ; BFS - add to end of OPEN list (queue)
                            ((eq type 'bfs) (setf OPEN (append OPEN (list child))))

                            ; DFID - add to start of OPEN list (stack)
                            ((eq type 'dfid)
                                ; check if node within depth bound
                                ( when ( < ( node-depth child ) bound )
                                    ; if within depth bound, add to open list
                                    (setf OPEN (cons child OPEN))
                                )
                            )

                            ; error handling for incorrect usage
                            (t (format t "SEARCH: bad search type! ~s~%" type) (return nil))
                        )
                    )
                )
            )
        )
    )
)

;--------------------------------------------------------------------------

; Build-solution takes a state and a list of (state parent) pairs
; and constructs the list of states that led to the current state
; by tracing back through the parents to the start node (nil parent).
(defun build-solution (node node-list)
    (do
        ((path (list (node-state node))))        ; local loop var
        ((null (node-parent node)) path)         ; termination condition

        ; find the parent of the current node
        (setf node (member-state (node-parent node) node-list))

        ; add it to the path
        (setf path (cons (node-state node) path))
    )
)

; Member-state looks for a node on the node-list with the same state.
(defun member-state (state node-list)
    (dolist (node node-list)
        (when (equal state (node-state node)) (return node))
    )
)